{"ast":null,"code":"'use strict';\n\nmodule.exports = jsx;\njsx.displayName = 'jsx';\njsx.aliases = [];\n\nfunction jsx(Prism) {\n  ;\n\n  (function (Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript);\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n    Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i;\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n    Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i;\n    Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n    Prism.languages.insertBefore('inside', 'attr-name', {\n      spread: {\n        pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\n        inside: {\n          punctuation: /\\.{3}|[{}.]/,\n          'attr-value': /\\w+/\n        }\n      }\n    }, Prism.languages.jsx.tag);\n    Prism.languages.insertBefore('inside', 'attr-value', {\n      script: {\n        // Allow for two levels of nesting\n        pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\n        inside: {\n          'script-punctuation': {\n            pattern: /^=(?={)/,\n            alias: 'punctuation'\n          },\n          rest: Prism.languages.jsx\n        },\n        alias: 'language-javascript'\n      }\n    }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (!token) {\n        return '';\n      }\n\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function (tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}","map":{"version":3,"sources":["C:/Users/aaron/Documents/lyncovid19-frontend-vercel/node_modules/refractor/lang/jsx.js"],"names":["module","exports","jsx","displayName","aliases","Prism","javascript","util","clone","languages","extend","tag","pattern","inside","insertBefore","spread","punctuation","script","alias","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token","hooks","add","env","language"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = jsx\r\njsx.displayName = 'jsx'\r\njsx.aliases = []\r\nfunction jsx(Prism) {\r\n  ;(function(Prism) {\r\n    var javascript = Prism.util.clone(Prism.languages.javascript)\r\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\r\n    Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i\r\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i\r\n    Prism.languages.jsx.tag.inside[\r\n      'attr-value'\r\n    ].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i\r\n    Prism.languages.jsx.tag.inside['tag'].inside[\r\n      'class-name'\r\n    ] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\r\n    Prism.languages.insertBefore(\r\n      'inside',\r\n      'attr-name',\r\n      {\r\n        spread: {\r\n          pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\r\n          inside: {\r\n            punctuation: /\\.{3}|[{}.]/,\r\n            'attr-value': /\\w+/\r\n          }\r\n        }\r\n      },\r\n      Prism.languages.jsx.tag\r\n    )\r\n    Prism.languages.insertBefore(\r\n      'inside',\r\n      'attr-value',\r\n      {\r\n        script: {\r\n          // Allow for two levels of nesting\r\n          pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\r\n          inside: {\r\n            'script-punctuation': {\r\n              pattern: /^=(?={)/,\r\n              alias: 'punctuation'\r\n            },\r\n            rest: Prism.languages.jsx\r\n          },\r\n          alias: 'language-javascript'\r\n        }\r\n      },\r\n      Prism.languages.jsx.tag\r\n    ) // The following will handle plain text inside tags\r\n    var stringifyToken = function(token) {\r\n      if (!token) {\r\n        return ''\r\n      }\r\n      if (typeof token === 'string') {\r\n        return token\r\n      }\r\n      if (typeof token.content === 'string') {\r\n        return token.content\r\n      }\r\n      return token.content.map(stringifyToken).join('')\r\n    }\r\n    var walkTokens = function(tokens) {\r\n      var openedTags = []\r\n      for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i]\r\n        var notTagNorBrace = false\r\n        if (typeof token !== 'string') {\r\n          if (\r\n            token.type === 'tag' &&\r\n            token.content[0] &&\r\n            token.content[0].type === 'tag'\r\n          ) {\r\n            // We found a tag, now find its kind\r\n            if (token.content[0].content[0].content === '</') {\r\n              // Closing tag\r\n              if (\r\n                openedTags.length > 0 &&\r\n                openedTags[openedTags.length - 1].tagName ===\r\n                  stringifyToken(token.content[0].content[1])\r\n              ) {\r\n                // Pop matching opening tag\r\n                openedTags.pop()\r\n              }\r\n            } else {\r\n              if (token.content[token.content.length - 1].content === '/>') {\r\n                // Autoclosed tag, ignore\r\n              } else {\r\n                // Opening tag\r\n                openedTags.push({\r\n                  tagName: stringifyToken(token.content[0].content[1]),\r\n                  openedBraces: 0\r\n                })\r\n              }\r\n            }\r\n          } else if (\r\n            openedTags.length > 0 &&\r\n            token.type === 'punctuation' &&\r\n            token.content === '{'\r\n          ) {\r\n            // Here we might have entered a JSX context inside a tag\r\n            openedTags[openedTags.length - 1].openedBraces++\r\n          } else if (\r\n            openedTags.length > 0 &&\r\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\r\n            token.type === 'punctuation' &&\r\n            token.content === '}'\r\n          ) {\r\n            // Here we might have left a JSX context inside a tag\r\n            openedTags[openedTags.length - 1].openedBraces--\r\n          } else {\r\n            notTagNorBrace = true\r\n          }\r\n        }\r\n        if (notTagNorBrace || typeof token === 'string') {\r\n          if (\r\n            openedTags.length > 0 &&\r\n            openedTags[openedTags.length - 1].openedBraces === 0\r\n          ) {\r\n            // Here we are inside a tag, and not inside a JSX context.\r\n            // That's plain text: drop any tokens matched.\r\n            var plainText = stringifyToken(token) // And merge text with adjacent text\r\n            if (\r\n              i < tokens.length - 1 &&\r\n              (typeof tokens[i + 1] === 'string' ||\r\n                tokens[i + 1].type === 'plain-text')\r\n            ) {\r\n              plainText += stringifyToken(tokens[i + 1])\r\n              tokens.splice(i + 1, 1)\r\n            }\r\n            if (\r\n              i > 0 &&\r\n              (typeof tokens[i - 1] === 'string' ||\r\n                tokens[i - 1].type === 'plain-text')\r\n            ) {\r\n              plainText = stringifyToken(tokens[i - 1]) + plainText\r\n              tokens.splice(i - 1, 1)\r\n              i--\r\n            }\r\n            tokens[i] = new Prism.Token(\r\n              'plain-text',\r\n              plainText,\r\n              null,\r\n              plainText\r\n            )\r\n          }\r\n        }\r\n        if (token.content && typeof token.content !== 'string') {\r\n          walkTokens(token.content)\r\n        }\r\n      }\r\n    }\r\n    Prism.hooks.add('after-tokenize', function(env) {\r\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\r\n        return\r\n      }\r\n      walkTokens(env.tokens)\r\n    })\r\n  })(Prism)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}