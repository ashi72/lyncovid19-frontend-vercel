{"ast":null,"code":"'use strict';\n\nmodule.exports = xquery;\nxquery.displayName = 'xquery';\nxquery.aliases = [];\n\nfunction xquery(Prism) {\n  ;\n\n  (function (Prism) {\n    Prism.languages.xquery = Prism.languages.extend('markup', {\n      'xquery-comment': {\n        pattern: /\\(:[\\s\\S]*?:\\)/,\n        greedy: true,\n        alias: 'comment'\n      },\n      string: {\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n        greedy: true\n      },\n      extension: {\n        pattern: /\\(#.+?#\\)/,\n        alias: 'symbol'\n      },\n      variable: /\\$[\\w-:]+/,\n      axis: {\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      'keyword-operator': {\n        pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n        lookbehind: true,\n        alias: 'operator'\n      },\n      keyword: {\n        pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n      'xquery-element': {\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'tag'\n      },\n      'xquery-attribute': {\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n        lookbehind: true,\n        alias: 'attr-name'\n      },\n      builtin: {\n        pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n        lookbehind: true\n      },\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n      operator: [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n        pattern: /(\\s)-(?=\\s)/,\n        lookbehind: true\n      }],\n      punctuation: /[[\\](){},;:/]/\n    });\n    Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i;\n    Prism.languages.xquery['tag'].inside['attr-value'].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^=\"|\"$/;\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\n      // Allow for two levels of nesting\n      pattern: /{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}/,\n      inside: {\n        rest: Prism.languages.xquery\n      },\n      alias: 'language-xquery'\n    }; // The following will handle plain text inside tags\n\n    var stringifyToken = function (token) {\n      if (typeof token === 'string') {\n        return token;\n      }\n\n      if (typeof token.content === 'string') {\n        return token.content;\n      }\n\n      return token.content.map(stringifyToken).join('');\n    };\n\n    var walkTokens = function (tokens) {\n      var openedTags = [];\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n        var notTagNorBrace = false;\n\n        if (typeof token !== 'string') {\n          if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n                // Pop matching opening tag\n                openedTags.pop();\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                });\n              }\n            }\n          } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{' && ( // Ignore `{{`\n          !tokens[i + 1] || tokens[i + 1].type !== 'punctuation' || tokens[i + 1].content !== '{') && (!tokens[i - 1] || tokens[i - 1].type !== 'plain-text' || tokens[i - 1].content !== '{')) {\n            // Here we might have entered an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces++;\n          } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n            // Here we might have left an XQuery expression inside a tag\n            openedTags[openedTags.length - 1].openedBraces--;\n          } else if (token.type !== 'comment') {\n            notTagNorBrace = true;\n          }\n        }\n\n        if (notTagNorBrace || typeof token === 'string') {\n          if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n            // Here we are inside a tag, and not inside an XQuery expression.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token); // And merge text with adjacent text\n\n            if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n              plainText += stringifyToken(tokens[i + 1]);\n              tokens.splice(i + 1, 1);\n            }\n\n            if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText;\n              tokens.splice(i - 1, 1);\n              i--;\n            }\n\n            if (/^\\s+$/.test(plainText)) {\n              tokens[i] = plainText;\n            } else {\n              tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n            }\n          }\n        }\n\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content);\n        }\n      }\n    };\n\n    Prism.hooks.add('after-tokenize', function (env) {\n      if (env.language !== 'xquery') {\n        return;\n      }\n\n      walkTokens(env.tokens);\n    });\n  })(Prism);\n}","map":{"version":3,"sources":["C:/Users/aaron/Documents/final-final-lyncovid-frontend/new-lynbrook-frontend/node_modules/refractor/lang/xquery.js"],"names":["module","exports","xquery","displayName","aliases","Prism","languages","extend","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword","function","builtin","number","operator","punctuation","tag","inside","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","test","Token","hooks","add","env","language"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nmodule.exports = xquery\r\nxquery.displayName = 'xquery'\r\nxquery.aliases = []\r\nfunction xquery(Prism) {\r\n  ;(function(Prism) {\r\n    Prism.languages.xquery = Prism.languages.extend('markup', {\r\n      'xquery-comment': {\r\n        pattern: /\\(:[\\s\\S]*?:\\)/,\r\n        greedy: true,\r\n        alias: 'comment'\r\n      },\r\n      string: {\r\n        pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\r\n        greedy: true\r\n      },\r\n      extension: {\r\n        pattern: /\\(#.+?#\\)/,\r\n        alias: 'symbol'\r\n      },\r\n      variable: /\\$[\\w-:]+/,\r\n      axis: {\r\n        pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\r\n        lookbehind: true,\r\n        alias: 'operator'\r\n      },\r\n      'keyword-operator': {\r\n        pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\r\n        lookbehind: true,\r\n        alias: 'operator'\r\n      },\r\n      keyword: {\r\n        pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\r\n        lookbehind: true\r\n      },\r\n      function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\r\n      'xquery-element': {\r\n        pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\r\n        lookbehind: true,\r\n        alias: 'tag'\r\n      },\r\n      'xquery-attribute': {\r\n        pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\r\n        lookbehind: true,\r\n        alias: 'attr-name'\r\n      },\r\n      builtin: {\r\n        pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\r\n        lookbehind: true\r\n      },\r\n      number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\r\n      operator: [\r\n        /[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/,\r\n        {\r\n          pattern: /(\\s)-(?=\\s)/,\r\n          lookbehind: true\r\n        }\r\n      ],\r\n      punctuation: /[[\\](){},;:/]/\r\n    })\r\n    Prism.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i\r\n    Prism.languages.xquery['tag'].inside[\r\n      'attr-value'\r\n    ].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i\r\n    Prism.languages.xquery['tag'].inside['attr-value'].inside[\r\n      'punctuation'\r\n    ] = /^=\"|\"$/\r\n    Prism.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {\r\n      // Allow for two levels of nesting\r\n      pattern: /{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}/,\r\n      inside: {\r\n        rest: Prism.languages.xquery\r\n      },\r\n      alias: 'language-xquery'\r\n    } // The following will handle plain text inside tags\r\n    var stringifyToken = function(token) {\r\n      if (typeof token === 'string') {\r\n        return token\r\n      }\r\n      if (typeof token.content === 'string') {\r\n        return token.content\r\n      }\r\n      return token.content.map(stringifyToken).join('')\r\n    }\r\n    var walkTokens = function(tokens) {\r\n      var openedTags = []\r\n      for (var i = 0; i < tokens.length; i++) {\r\n        var token = tokens[i]\r\n        var notTagNorBrace = false\r\n        if (typeof token !== 'string') {\r\n          if (\r\n            token.type === 'tag' &&\r\n            token.content[0] &&\r\n            token.content[0].type === 'tag'\r\n          ) {\r\n            // We found a tag, now find its kind\r\n            if (token.content[0].content[0].content === '</') {\r\n              // Closing tag\r\n              if (\r\n                openedTags.length > 0 &&\r\n                openedTags[openedTags.length - 1].tagName ===\r\n                  stringifyToken(token.content[0].content[1])\r\n              ) {\r\n                // Pop matching opening tag\r\n                openedTags.pop()\r\n              }\r\n            } else {\r\n              if (token.content[token.content.length - 1].content === '/>') {\r\n                // Autoclosed tag, ignore\r\n              } else {\r\n                // Opening tag\r\n                openedTags.push({\r\n                  tagName: stringifyToken(token.content[0].content[1]),\r\n                  openedBraces: 0\r\n                })\r\n              }\r\n            }\r\n          } else if (\r\n            openedTags.length > 0 &&\r\n            token.type === 'punctuation' &&\r\n            token.content === '{' && // Ignore `{{`\r\n            (!tokens[i + 1] ||\r\n              tokens[i + 1].type !== 'punctuation' ||\r\n              tokens[i + 1].content !== '{') &&\r\n            (!tokens[i - 1] ||\r\n              tokens[i - 1].type !== 'plain-text' ||\r\n              tokens[i - 1].content !== '{')\r\n          ) {\r\n            // Here we might have entered an XQuery expression inside a tag\r\n            openedTags[openedTags.length - 1].openedBraces++\r\n          } else if (\r\n            openedTags.length > 0 &&\r\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\r\n            token.type === 'punctuation' &&\r\n            token.content === '}'\r\n          ) {\r\n            // Here we might have left an XQuery expression inside a tag\r\n            openedTags[openedTags.length - 1].openedBraces--\r\n          } else if (token.type !== 'comment') {\r\n            notTagNorBrace = true\r\n          }\r\n        }\r\n        if (notTagNorBrace || typeof token === 'string') {\r\n          if (\r\n            openedTags.length > 0 &&\r\n            openedTags[openedTags.length - 1].openedBraces === 0\r\n          ) {\r\n            // Here we are inside a tag, and not inside an XQuery expression.\r\n            // That's plain text: drop any tokens matched.\r\n            var plainText = stringifyToken(token) // And merge text with adjacent text\r\n            if (\r\n              i < tokens.length - 1 &&\r\n              (typeof tokens[i + 1] === 'string' ||\r\n                tokens[i + 1].type === 'plain-text')\r\n            ) {\r\n              plainText += stringifyToken(tokens[i + 1])\r\n              tokens.splice(i + 1, 1)\r\n            }\r\n            if (\r\n              i > 0 &&\r\n              (typeof tokens[i - 1] === 'string' ||\r\n                tokens[i - 1].type === 'plain-text')\r\n            ) {\r\n              plainText = stringifyToken(tokens[i - 1]) + plainText\r\n              tokens.splice(i - 1, 1)\r\n              i--\r\n            }\r\n            if (/^\\s+$/.test(plainText)) {\r\n              tokens[i] = plainText\r\n            } else {\r\n              tokens[i] = new Prism.Token(\r\n                'plain-text',\r\n                plainText,\r\n                null,\r\n                plainText\r\n              )\r\n            }\r\n          }\r\n        }\r\n        if (token.content && typeof token.content !== 'string') {\r\n          walkTokens(token.content)\r\n        }\r\n      }\r\n    }\r\n    Prism.hooks.add('after-tokenize', function(env) {\r\n      if (env.language !== 'xquery') {\r\n        return\r\n      }\r\n      walkTokens(env.tokens)\r\n    })\r\n  })(Prism)\r\n}\r\n"]},"metadata":{},"sourceType":"script"}